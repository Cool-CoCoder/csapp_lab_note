这个网站超级赞, 可以学习详细gdb文档 https://visualgdb.com/gdbreference/commands/
不过有一些没找到的操作还是自行百度

**提醒**：一下如果你用的是M1芯片, arm64/v8架构的芯片虽然也有ubuntu、centos等系统, 但系统很多工具还没有做, 暂时还不能做实验, 解决方案就是租个服务器, 老老实实用amd64的机器.

前面几个实验比较基础, 分享一下问题6和隐藏关卡记录, 详细的解析可以百度其他人的

# phase_6
```
0x0000000000401153 <+95>:	lea    0x18(%rsp),%rsi
0x0000000000401158 <+100>:	mov    %r14,%rax
0x000000000040115b <+103>:	mov    $0x7,%ecx
0x0000000000401160 <+108>:	mov    %ecx,%edx
0x0000000000401162 <+110>:	sub    (%rax),%edx
0x0000000000401164 <+112>:	mov    %edx,(%rax)
0x0000000000401166 <+114>:	add    $0x4,%rax
0x000000000040116a <+118>:	cmp    %rsi,%rax
0x000000000040116d <+121>:	jne    0x401160 <phase_6+108>
0x000000000040116f <+123>:	mov    $0x0,%esi       esi == 0
```

通过研究可以指导这是将数组每个元素都用7-x放进去, 然后指针+4，就像for循环中的i++, 注意一开始rsi=0. 但是我很好奇为什么rax一直+4最后会和rsi的0做比较控制跳转. 后来打印了很多地址的数据，看到rax后面的地址值会为0，但cmp是比较两个寄存器的值还是比较地址指向的值呢？
通过研究, rax是地址寄存器，rsi值为0，将0和rax指向的内容进行比较. 
```
0x00000000004010f4 <+0>:	push   %r14
0x00000000004010f6 <+2>:	push   %r13
0x00000000004010f8 <+4>:	push   %r12
0x00000000004010fa <+6>:	push   %rbp
0x00000000004010fb <+7>:	push   %rbx
0x00000000004010fc <+8>:	sub    $0x50,%rsp
0x0000000000401100 <+12>:	mov    %rsp,%r13
0x0000000000401103 <+15>:	mov    %rsp,%rsi
0x0000000000401106 <+18>:	callq  0x40145c <read_six_numbers>
0x000000000040110b <+23>:	mov    %rsp,%r14
0x000000000040110e <+26>:	mov    $0x0,%r12d
0x0000000000401114 <+32>:	mov    %r13,%rbp
0x0000000000401117 <+35>:	mov    0x0(%r13),%eax
0x000000000040111b <+39>:	sub    $0x1,%eax
0x000000000040111e <+42>:	cmp    $0x5,%eax
0x0000000000401121 <+45>:	jbe    0x401128 <phase_6+52>
0x0000000000401123 <+47>:	callq  0x40143a <explode_bomb>
0x0000000000401128 <+52>:	add    $0x1,%r12d
0x000000000040112c <+56>:	cmp    $0x6,%r12d
0x0000000000401130 <+60>:	je     0x401153 <phase_6+95>
0x0000000000401132 <+62>:	mov    %r12d,%ebx
0x0000000000401135 <+65>:	movslq %ebx,%rax
0x0000000000401138 <+68>:	mov    (%rsp,%rax,4),%eax
0x000000000040113b <+71>:	cmp    %eax,0x0(%rbp)
0x000000000040113e <+74>:	jne    0x401145 <phase_6+81>
0x0000000000401140 <+76>:	callq  0x40143a <explode_bomb>
0x0000000000401145 <+81>:	add    $0x1,%ebx
0x0000000000401148 <+84>:	cmp    $0x5,%ebx
0x000000000040114b <+87>:	jle    0x401135 <phase_6+65>
0x000000000040114d <+89>:	add    $0x4,%r13
0x0000000000401151 <+93>:	jmp    0x401114 <phase_6+32>
0x0000000000401153 <+95>:	lea    0x18(%rsp),%rsi
0x0000000000401158 <+100>:	mov    %r14,%rax
0x000000000040115b <+103>:	mov    $0x7,%ecx
0x0000000000401160 <+108>:	mov    %ecx,%edx
0x0000000000401162 <+110>:	sub    (%rax),%edx
0x0000000000401164 <+112>:	mov    %edx,(%rax)
0x0000000000401166 <+114>:	add    $0x4,%rax
0x000000000040116a <+118>:	cmp    %rsi,%rax
0x000000000040116d <+121>:	jne    0x401160 <phase_6+108>

0x000000000040116f <+123>:	mov    $0x0,%esi       esi == 0
0x0000000000401174 <+128>:	jmp    0x401197 <phase_6+163> 

// 循环到ecx与eax相等, eax初始为1, 而ecx就是我们输入的6个数字之1, 130行一直在做一个
rdx = rdx + 8的操作
0x0000000000401176 <+130>:	mov    0x8(%rdx),%rdx
0x000000000040117a <+134>:	add    $0x1,%eax
0x000000000040117d <+137>:	cmp    %ecx,%eax    
0x000000000040117f <+139>:	jne    0x401176 <phase_6+130>
0x0000000000401181 <+141>:	jmp    0x401188 <phase_6+148>


0x0000000000401183 <+143>:	mov    $0x6032d0,%edx
------------------------------------------------
0x6032d0 <node1>:       332     1       6304480 0      16bytes
0x6032e0 <node2>:       168     2       6304496 0
0x6032f0 <node3>:       924     3       6304512 0
0x603300 <node4>:       691     4       6304528 0
0x603310 <node5>:       477     5       6304544 0
0x603320 <node6>:       443     6       0       0
------------------------------------------------

------------------------------------------------    
(gdb) x/12xg 0x6032d0
0x6032d0 <node1>:       0x000000010000014c      0x0000000000603310
0x6032e0 <node2>:       0x00000002000000a8      0x0000000000603320
0x6032f0 <node3>:       0x000000030000039c      0x00000000006032e0
0x603300 <node4>:       0x00000004000002b3      0x00000000006032f0
0x603310 <node5>:       0x00000005000001dd      0x0000000000603300
0x603320 <node6>:       0x00000006000001bb      0x0000000000000000
------------------------------------------------
    
// 初始
------------------------------------------------
(gdb) x/30d 0x7fffffffe2e0
0x7fffffffe2e0: 1       5       4       3
0x7fffffffe2f0: 2       6       0       0
------------------------------------------------

------------------------------------------------
// 可以看到变化
(gdb) x/30d 0x7fffffffe2e0
0x7fffffffe2e0: 1       5       4       3
0x7fffffffe2f0: 2       6       0       0
0x7fffffffe300: 6304464 0       6304528 0
0x7fffffffe310: 6304512 0       4199372 0
0x7fffffffe320: 0       0       6306064 0
------------------------------------------------


// 148行就是一个将寄存器值赋给内存
0x0000000000401188 <+148>:	mov    %rdx,0x20(%rsp,%rsi,2)
0x000000000040118d <+153>:	add    $0x4,%rsi
// 根据rsi 循环6次
0x0000000000401191 <+157>:	cmp    $0x18,%rsi
0x0000000000401195 <+161>:	je     0x4011ab <phase_6+183>

0x0000000000401197 <+163>:	mov    (%rsp,%rsi,1),%ecx   
// ecx≤1则jump 143, 否则jump 130
0x000000000040119a <+166>:	cmp    $0x1,%ecx
0x000000000040119d <+169>:	jle    0x401183 <phase_6+143>
0x000000000040119f <+171>:	mov    $0x1,%eax
0x00000000004011a4 <+176>:	mov    $0x6032d0,%edx
0x00000000004011a9 <+181>:	jmp    0x401176 <phase_6+130>

------------------------------------------------
│rax            0x7fffffffe310      140737488347920                                      │
│rbx            0x6032d0            6304464                                              │
│rcx            0x6032d0            6304464                                              │
│rdx            0x603310            6304528                                              │
│rsi            0x7fffffffe330      140737488347952                                      │
│rdi            0x7fffffffdc70      140737488346224                                      │
│rbp            0x7fffffffe2f4      0x7fffffffe2f4                                       │
│rsp            0x7fffffffe2e0      0x7fffffffe2e0  
------------------------------------------------
    
// 32 + rsp
0x00000000004011ab <+183>:	mov    0x20(%rsp),%rbx
// 40 + rsp
0x00000000004011b0 <+188>:	lea    0x28(%rsp),%rax

// 80 + rsp
0x00000000004011b5 <+193>:	lea    0x50(%rsp),%rsi
// rbx -> rcx 
0x00000000004011ba <+198>:	mov    %rbx,%rcx

0x00000000004011bd <+201>:	mov    (%rax),%rdx
0x00000000004011c0 <+204>:	mov    %rdx,0x8(%rcx)
0x00000000004011c4 <+208>:	add    $0x8,%rax

// 可以看出rax在一直加8然后会与rsi比较, 那么就是5次, 这几步我看也只是个把数值放在一个位置的操作, 我们再打别的断点
0x00000000004011c8 <+212>:	cmp    %rsi,%rax
0x00000000004011cb <+215>:	je     0x4011d2 <phase_6+222>

0x00000000004011cd <+217>:	mov    %rdx,%rcx  
0x00000000004011d0 <+220>:	jmp    0x4011bd <phase_6+201>

0x00000000004011d2 <+222>:	movq   $0x0,0x8(%rdx)
0x00000000004011da <+230>:	mov    $0x5,%ebp
0x00000000004011df <+235>:	mov    0x8(%rbx),%rax
0x00000000004011e3 <+239>:	mov    (%rax),%eax
0x00000000004011e5 <+241>:	cmp    %eax,(%rbx)
0x00000000004011e7 <+243>:	jge    0x4011ee <phase_6+250>
0x00000000004011e9 <+245>:	callq  0x40143a <explode_bomb>

0x00000000004011ee <+250>:	mov    0x8(%rbx),%rbx
0x00000000004011f2 <+254>:	sub    $0x1,%ebp
0x00000000004011f5 <+257>:	jne    0x4011df <phase_6+235>
0x00000000004011f7 <+259>:	add    $0x50,%rsp
0x00000000004011fb <+263>:	pop    %rbx
0x00000000004011fc <+264>:	pop    %rbp
0x00000000004011fd <+265>:	pop    %r12
0x00000000004011ff <+267>:	pop    %r13
0x0000000000401201 <+269>:	pop    %r14
0x0000000000401203 <+271>:	retq   
```
# secret_phase

```
Dump of assembler code for function phase_defused:
0x00000000004015c4 <+0>:	sub    $0x78,%rsp
0x00000000004015c8 <+4>:	mov    %fs:0x28,%rax
0x00000000004015d1 <+13>:	mov    %rax,0x68(%rsp)
0x00000000004015d6 <+18>:	xor    %eax,%eax
0x00000000004015d8 <+20>:	cmpl   $0x6,0x202181(%rip)        # 0x603760 <num_input_strings>
----------------------------------------------
可以尝试每拆开一个炸弹查询一次， 设置断点然后continue就行了
0x603760 <num_input_strings>:   1
...
0x603760 <num_input_strings>:   4
0x603760 <num_input_strings>:   5
0x603760 <num_input_strings>:   6
----------------------------------------------
    
0x00000000004015df <+27>:	jne    0x40163f <phase_defused+123>

//准备进入秘密阶段
0x00000000004015e1 <+29>:	lea    0x10(%rsp),%r8
0x00000000004015e6 <+34>:	lea    0xc(%rsp),%rcx
0x00000000004015eb <+39>:	lea    0x8(%rsp),%rdx
----------------------------------------------
(gdb) x/s 0x402619
0x402619:	"%d %d %s"
    
(gdb) x/s 0x603870
0x603870 <input_strings+240>:	"0 0."    // 提示：我们第四行输入的就是0 0 
    
(gdb) x/s 0x402622
0x402622:	"DrEvil" // 我们因此需要在第四行加上这个
----------------------------------------------
0x00000000004015f0 <+44>:	mov    $0x402619,%esi
0x00000000004015f5 <+49>:	mov    $0x603870,%edi
0x00000000004015fa <+54>:	callq  0x400bf0 <__isoc99_sscanf@plt>
// 和3比较一次, eax由scanf确定, 很明显就是确认我们第四行有几个元素
0x00000000004015ff <+59>:	cmp    $0x3,%eax   
0x0000000000401602 <+62>:	jne    0x401635 <phase_defused+113>
0x0000000000401604 <+64>:	mov    $0x402622,%esi
0x0000000000401609 <+69>:	lea    0x10(%rsp),%rdi
0x000000000040160e <+74>:	callq  0x401338 <strings_not_equal>
0x0000000000401613 <+79>:	test   %eax,%eax
0x0000000000401615 <+81>:	jne    0x401635 <phase_defused+113>
----------------------------------------------
// 准备启程了,可以看到下面一路绿灯准备进入secret_phase	
(gdb) x/d 0x4024f8
0x4024f8:	1936880963
(gdb) x/s 0x4024f8
0x4024f8:	"Curses, you've found the secret phase!"
(gdb) x/s 0x402520
0x402520:	"But finding it and solving it are quite different..."
----------------------------------------------
    
0x0000000000401617 <+83>:	mov    $0x4024f8,%edi
0x000000000040161c <+88>:	callq  0x400b10 <puts@plt>
0x0000000000401621 <+93>:	mov    $0x402520,%edi
0x0000000000401626 <+98>:	callq  0x400b10 <puts@plt>
0x000000000040162b <+103>:	mov    $0x0,%eax
0x0000000000401630 <+108>:	callq  0x401242 <secret_phase>
0x0000000000401635 <+113>:	mov    $0x402558,%edi
0x000000000040163a <+118>:	callq  0x400b10 <puts@plt>
0x000000000040163f <+123>:	mov    0x68(%rsp),%rax
0x0000000000401644 <+128>:	xor    %fs:0x28,%rax
0x000000000040164d <+137>:	je     0x401654 <phase_defused+144>
0x000000000040164f <+139>:	callq  0x400b30 <__stack_chk_fail@plt>
0x0000000000401654 <+144>:	add    $0x78,%rsp
0x0000000000401658 <+148>:	retq   
End of assembler dump.


```


```
(gdb) disas secret_phase
Dump of assembler code for function secret_phase:
   0x0000000000401242 <+0>:	push   %rbx
   0x0000000000401243 <+1>:	callq  0x40149e <read_line>
   0x0000000000401248 <+6>:	mov    $0xa,%edx
   0x000000000040124d <+11>:	mov    $0x0,%esi
   0x0000000000401252 <+16>:	mov    %rax,%rdi
   0x0000000000401255 <+19>:	callq  0x400bd0 <strtol@plt> //这个标准库函数的作用是把一个字符串转换成对应的长整型数值， 我们需要在原先答案下加上一行数字, 小于1001就可以进入fun7了(好像不能是负数,因为我们不输入的时候炸弹会爆炸)
   0x000000000040125a <+24>:	mov    %rax,%rbx
   0x000000000040125d <+27>:	lea    -0x1(%rax),%eax
   0x0000000000401260 <+30>:	cmp    $0x3e8,%eax // 0x3e8=1000
   0x0000000000401265 <+35>:	jbe    0x40126c <secret_phase+42>
   0x0000000000401267 <+37>:	callq  0x40143a <explode_bomb>
   0x000000000040126c <+42>:	mov    %ebx,%esi
   0x000000000040126e <+44>:	mov    $0x6030f0,%edi
   0x0000000000401273 <+49>:	callq  0x401204 <fun7>
   // 如果fun7返回2, 那么我们就成功拆除了炸弹
   0x0000000000401278 <+54>:	cmp    $0x2,%eax
   0x000000000040127b <+57>:	je     0x401282 <secret_phase+64>
   0x000000000040127d <+59>:	callq  0x40143a <explode_bomb>
   0x0000000000401282 <+64>:	mov    $0x402438,%edi
   0x0000000000401287 <+69>:	callq  0x400b10 <puts@plt>
   0x000000000040128c <+74>:	callq  0x4015c4 <phase_defused>
   0x0000000000401291 <+79>:	pop    %rbx
   0x0000000000401292 <+80>:	retq   
End of assembler dump.
```

```
(gdb) disas fun7
Dump of assembler code for function fun7:

<+0>:	sub    $0x8,%rsp
0x0000000000401208 <+4>:	test   %rdi,%rdi
0x000000000040120b <+7>:	je     0x401238 <fun7+52> //je 表示等于0则跳转

0x000000000040120d <+9>:	mov    (%rdi),%edx
0x000000000040120f <+11>:	cmp    %esi,%edx    // esi 是我们输入的值
0x0000000000401211 <+13>:	jle    0x401220 <fun7+28>

0x0000000000401213 <+15>:	mov    0x8(%rdi),%rdi
0x0000000000401217 <+19>:	callq  0x401204 <fun7>  // 是不是像递归呢？ call具体忘了可以去查资料, 然后研究函数到底返回的是什么
0x000000000040121c <+24>:	add    %eax,%eax
0x000000000040121e <+26>:	jmp    0x40123d <fun7+57>

0x0000000000401220 <+28>:	mov    $0x0,%eax
0x0000000000401225 <+33>:	cmp    %esi,%edx     
0x0000000000401227 <+35>:	je     0x40123d <fun7+57>

0x0000000000401229 <+37>:	mov    0x10(%rdi),%rdi
0x000000000040122d <+41>:	callq  0x401204 <fun7> // 同上一个
0x0000000000401232 <+46>:	lea    0x1(%rax,%rax,1),%eax 
0x0000000000401236 <+50>:	jmp    0x40123d <fun7+57>

0x0000000000401238 <+52>:	mov    $0xffffffff,%eax // 运行到52行就凉了
0x000000000040123d <+57>:	add    $0x8,%rsp
0x0000000000401241 <+61>:	retq   
End of assembler dump.
    
    
我们容易发现这就是一棵BST， 
(gdb) x/128xg 0x6030f0
0x6030f0 <n1>:	0x0000000000000024	0x0000000000603110
0x603100 <n1+16>:	0x0000000000603130	0x0000000000000000
0x603110 <n21>:	0x0000000000000008	0x0000000000603190
0x603120 <n21+16>:	0x0000000000603150	0x0000000000000000
0x603130 <n22>:	0x0000000000000032	0x0000000000603170
0x603140 <n22+16>:	0x00000000006031b0	0x0000000000000000
0x603150 <n32>:	0x0000000000000016	0x0000000000603270
0x603160 <n32+16>:	0x0000000000603230	0x0000000000000000
0x603170 <n33>:	0x000000000000002d	0x00000000006031d0
0x603180 <n33+16>:	0x0000000000603290	0x0000000000000000
0x603190 <n31>:	0x0000000000000006	0x00000000006031f0
0x6031a0 <n31+16>:	0x0000000000603250	0x0000000000000000
0x6031b0 <n34>:	0x000000000000006b	0x0000000000603210
0x6031c0 <n34+16>:	0x00000000006032b0	0x0000000000000000
0x6031d0 <n45>:	0x0000000000000028	0x0000000000000000
0x6031e0 <n45+16>:	0x0000000000000000	0x0000000000000000
0x6031f0 <n41>:	0x0000000000000001	0x0000000000000000
0x603200 <n41+16>:	0x0000000000000000	0x0000000000000000
0x603210 <n47>:	0x0000000000000063	0x0000000000000000
0x603220 <n47+16>:	0x0000000000000000	0x0000000000000000
0x603230 <n44>:	0x0000000000000023	0x0000000000000000
0x603240 <n44+16>:	0x0000000000000000	0x0000000000000000
0x603250 <n42>:	0x0000000000000007	0x0000000000000000
0x603260 <n42+16>:	0x0000000000000000	0x0000000000000000
0x603270 <n43>:	0x0000000000000014	0x0000000000000000
0x603280 <n43+16>:	0x0000000000000000	0x0000000000000000
0x603290 <n46>:	0x000000000000002f	0x0000000000000000
0x6032a0 <n46+16>:	0x0000000000000000	0x0000000000000000
0x6032b0 <n48>:	0x00000000000003e9	0x0000000000000000
0x6032c0 <n48+16>:	0x0000000000000000	0x0000000000000000

仔细观察可以发现这是一个二叉树的结构，每个节点第1个8字节存放数据，第2个8字节存放左子树地址，第3个8字节存放右子树位置。
我们要返回2, 那就是0->0+1->2*1 -> 2，从上往下就是左右等, 不嫌麻烦可以顺着地址找, 那就是
0x603150 <n32>:	0x0000000000000016	0x0000000000603270
0x16 = 22， 恭喜, 实验完成了!

// 顺利完成实验
root@instance-bexsitjk:~/labs/bomb# ./bomb ans.txt 
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
That's number 2.  Keep going!
Halfway there!
So you got that one.  Try this one.
Good work!  On to the next...
Curses, you've found the secret phase!
But finding it and solving it are quite different...
Wow! You've defused the secret stage!
Congratulations! You've defused the bomb!
```
