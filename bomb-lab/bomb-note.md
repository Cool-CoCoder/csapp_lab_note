这个网站超级赞, 可以学习详细gdb文档 https://visualgdb.com/gdbreference/commands/,不过有一些没找到的操作还是自行百度

**提醒**：一下如果你用的是M1芯片, arm64/v8架构的芯片虽然也有ubuntu、centos等系统, 但系统很多工具还没有做, 暂时还不能做实验, 解决方案就是租个服务器, 老老实实用amd64的机器.

前面几个实验比较基础, 分享一下问题6的记录


通过研究可以指导这是将数组每个元素都用7-x放进去, 然后指针+4，就像for循环中的i++, 注意一开始rsi=0. 但是我很好奇为什么rax一直+4最后会和rsi的0做比较控制跳转. 后来打印了很多地址的数据，看到rax后面的地址值会为0，但cmp是比较两个寄存器的值还是比较地址指向的值呢？

懂了！！！rax是地址寄存器，rsi值为0，将0和rax指向的内容进行比较. 
```
0x00000000004010f4 <+0>:	push   %r14
0x00000000004010f6 <+2>:	push   %r13
0x00000000004010f8 <+4>:	push   %r12
0x00000000004010fa <+6>:	push   %rbp
0x00000000004010fb <+7>:	push   %rbx
0x00000000004010fc <+8>:	sub    $0x50,%rsp
0x0000000000401100 <+12>:	mov    %rsp,%r13
0x0000000000401103 <+15>:	mov    %rsp,%rsi
0x0000000000401106 <+18>:	callq  0x40145c <read_six_numbers>
0x000000000040110b <+23>:	mov    %rsp,%r14
0x000000000040110e <+26>:	mov    $0x0,%r12d
0x0000000000401114 <+32>:	mov    %r13,%rbp
0x0000000000401117 <+35>:	mov    0x0(%r13),%eax
0x000000000040111b <+39>:	sub    $0x1,%eax
0x000000000040111e <+42>:	cmp    $0x5,%eax
0x0000000000401121 <+45>:	jbe    0x401128 <phase_6+52>
0x0000000000401123 <+47>:	callq  0x40143a <explode_bomb>
0x0000000000401128 <+52>:	add    $0x1,%r12d
0x000000000040112c <+56>:	cmp    $0x6,%r12d
0x0000000000401130 <+60>:	je     0x401153 <phase_6+95>
0x0000000000401132 <+62>:	mov    %r12d,%ebx
0x0000000000401135 <+65>:	movslq %ebx,%rax
0x0000000000401138 <+68>:	mov    (%rsp,%rax,4),%eax
0x000000000040113b <+71>:	cmp    %eax,0x0(%rbp)
0x000000000040113e <+74>:	jne    0x401145 <phase_6+81>
0x0000000000401140 <+76>:	callq  0x40143a <explode_bomb>
0x0000000000401145 <+81>:	add    $0x1,%ebx
0x0000000000401148 <+84>:	cmp    $0x5,%ebx
0x000000000040114b <+87>:	jle    0x401135 <phase_6+65>
0x000000000040114d <+89>:	add    $0x4,%r13
0x0000000000401151 <+93>:	jmp    0x401114 <phase_6+32>
0x0000000000401153 <+95>:	lea    0x18(%rsp),%rsi
0x0000000000401158 <+100>:	mov    %r14,%rax
0x000000000040115b <+103>:	mov    $0x7,%ecx
0x0000000000401160 <+108>:	mov    %ecx,%edx
0x0000000000401162 <+110>:	sub    (%rax),%edx
0x0000000000401164 <+112>:	mov    %edx,(%rax)
0x0000000000401166 <+114>:	add    $0x4,%rax
0x000000000040116a <+118>:	cmp    %rsi,%rax
0x000000000040116d <+121>:	jne    0x401160 <phase_6+108>

0x000000000040116f <+123>:	mov    $0x0,%esi       esi == 0
0x0000000000401174 <+128>:	jmp    0x401197 <phase_6+163> 

// 循环到ecx与eax相等, eax初始为1, 而ecx就是我们输入的6个数字之1, 130行一直在做一个
rdx = rdx + 8的操作
0x0000000000401176 <+130>:	mov    0x8(%rdx),%rdx
0x000000000040117a <+134>:	add    $0x1,%eax
0x000000000040117d <+137>:	cmp    %ecx,%eax    
0x000000000040117f <+139>:	jne    0x401176 <phase_6+130>
0x0000000000401181 <+141>:	jmp    0x401188 <phase_6+148>


0x0000000000401183 <+143>:	mov    $0x6032d0,%edx
------------------------------------------------
0x6032d0 <node1>:       332     1       6304480 0      16bytes
0x6032e0 <node2>:       168     2       6304496 0
0x6032f0 <node3>:       924     3       6304512 0
0x603300 <node4>:       691     4       6304528 0
0x603310 <node5>:       477     5       6304544 0
0x603320 <node6>:       443     6       0       0
------------------------------------------------

------------------------------------------------    
(gdb) x/12xg 0x6032d0
0x6032d0 <node1>:       0x000000010000014c      0x0000000000603310
0x6032e0 <node2>:       0x00000002000000a8      0x0000000000603320
0x6032f0 <node3>:       0x000000030000039c      0x00000000006032e0
0x603300 <node4>:       0x00000004000002b3      0x00000000006032f0
0x603310 <node5>:       0x00000005000001dd      0x0000000000603300
0x603320 <node6>:       0x00000006000001bb      0x0000000000000000
------------------------------------------------
    
// 初始
------------------------------------------------
(gdb) x/30d 0x7fffffffe2e0
0x7fffffffe2e0: 1       5       4       3
0x7fffffffe2f0: 2       6       0       0
------------------------------------------------

------------------------------------------------
// 可以看到变化
(gdb) x/30d 0x7fffffffe2e0
0x7fffffffe2e0: 1       5       4       3
0x7fffffffe2f0: 2       6       0       0
0x7fffffffe300: 6304464 0       6304528 0
0x7fffffffe310: 6304512 0       4199372 0
0x7fffffffe320: 0       0       6306064 0
------------------------------------------------


// 148行就是一个将寄存器值赋给内存
0x0000000000401188 <+148>:	mov    %rdx,0x20(%rsp,%rsi,2)
0x000000000040118d <+153>:	add    $0x4,%rsi
// 根据rsi 循环6次
0x0000000000401191 <+157>:	cmp    $0x18,%rsi
0x0000000000401195 <+161>:	je     0x4011ab <phase_6+183>

0x0000000000401197 <+163>:	mov    (%rsp,%rsi,1),%ecx   
// ecx≤1则jump 143, 否则jump 130
0x000000000040119a <+166>:	cmp    $0x1,%ecx
0x000000000040119d <+169>:	jle    0x401183 <phase_6+143>
0x000000000040119f <+171>:	mov    $0x1,%eax
0x00000000004011a4 <+176>:	mov    $0x6032d0,%edx
0x00000000004011a9 <+181>:	jmp    0x401176 <phase_6+130>

------------------------------------------------
│rax            0x7fffffffe310      140737488347920                                      │
│rbx            0x6032d0            6304464                                              │
│rcx            0x6032d0            6304464                                              │
│rdx            0x603310            6304528                                              │
│rsi            0x7fffffffe330      140737488347952                                      │
│rdi            0x7fffffffdc70      140737488346224                                      │
│rbp            0x7fffffffe2f4      0x7fffffffe2f4                                       │
│rsp            0x7fffffffe2e0      0x7fffffffe2e0  
------------------------------------------------
    
// 32 + rsp
0x00000000004011ab <+183>:	mov    0x20(%rsp),%rbx
// 40 + rsp
0x00000000004011b0 <+188>:	lea    0x28(%rsp),%rax

// 80 + rsp
0x00000000004011b5 <+193>:	lea    0x50(%rsp),%rsi
// rbx -> rcx 
0x00000000004011ba <+198>:	mov    %rbx,%rcx

0x00000000004011bd <+201>:	mov    (%rax),%rdx
0x00000000004011c0 <+204>:	mov    %rdx,0x8(%rcx)
0x00000000004011c4 <+208>:	add    $0x8,%rax

// 可以看出rax在一直加8然后会与rsi比较, 那么就是5次, 这几步我看也只是个把数值放在一个位置的操作, 我们再打别的断点
0x00000000004011c8 <+212>:	cmp    %rsi,%rax
0x00000000004011cb <+215>:	je     0x4011d2 <phase_6+222>

0x00000000004011cd <+217>:	mov    %rdx,%rcx  
0x00000000004011d0 <+220>:	jmp    0x4011bd <phase_6+201>

0x00000000004011d2 <+222>:	movq   $0x0,0x8(%rdx)
0x00000000004011da <+230>:	mov    $0x5,%ebp
0x00000000004011df <+235>:	mov    0x8(%rbx),%rax
0x00000000004011e3 <+239>:	mov    (%rax),%eax
0x00000000004011e5 <+241>:	cmp    %eax,(%rbx)
0x00000000004011e7 <+243>:	jge    0x4011ee <phase_6+250>
0x00000000004011e9 <+245>:	callq  0x40143a <explode_bomb>

0x00000000004011ee <+250>:	mov    0x8(%rbx),%rbx
0x00000000004011f2 <+254>:	sub    $0x1,%ebp
0x00000000004011f5 <+257>:	jne    0x4011df <phase_6+235>
0x00000000004011f7 <+259>:	add    $0x50,%rsp
0x00000000004011fb <+263>:	pop    %rbx
0x00000000004011fc <+264>:	pop    %rbp
0x00000000004011fd <+265>:	pop    %r12
0x00000000004011ff <+267>:	pop    %r13
0x0000000000401201 <+269>:	pop    %r14
0x0000000000401203 <+271>:	retq   
```
